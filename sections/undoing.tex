\begin{frame}{Undoing Changes}{Restore}
\begin{itemize}
  \item Unmodify changes (to the last commit)
    \comm{git restore FILE\_NAME}
  \item Restore one file to three commits prior to HEAD
    \comm{git restore source=HEAD$\sim$3 FILE\_NAME}
    \comm{git restore FILE\_NAME} (unstage the file)
    \comm{git restore \dhyphen staged FILE\_NAME} (unstage the file)
\end{itemize}
\end{frame}

\begin{frame}{Undoing Changes}{Reset}
\begin{itemize}
  \item Unsaging a file
    \comm{git reset HEAD SOME\_FILE}
  \item Becareful: This command removes the history.
    \comm{git reset <hash-commit>}
    \comm{git reset HEAD$\sim$3} (moves the HEAD to 3 commits before current, but keep the changes)
    \begin{center}
    {\color{red} Careful: The last 3 commit will be removed}
  \end{center}
    \comm{git reset --hard HEAD$\sim$3} (moves the HEAD to 3 commits before current and do nor keep the changes)
    \begin{center}
      {\color{red} Be even more careful}
  \end{center}
\end{itemize}
{\textbf{ \color{green} Alternative:}} {\footnotesize "git revert", which instead deleting intermediate 
commits, brings the commit of desire forward and creates a new commit upon merging.
"git reset" may be used very carefully, only you want to reset to some prior commit, 
since which you have not pushed anything into the remote.}
\end{frame}

\begin{frame}{Undoing Changes}{Revert}
\begin{itemize}
  \item syntax for revert is very similar to reset. They differ only in the way things are done
\end{itemize}
\end{frame}
